---
title: "Raspando a Lista de Baralhos de Gwent"
description: |
  Gwent é um jogo de cartas que nasceu dentro do universo de The Witcher e, dada a popularidade da franquia, chegou aos smartphones. A comunidade de jogadores é bastante ativa, e existe uma lista de baralhos montados por ela que está disponível dentro do site oficial do jogo. Meu objetivo neste post será raspar esta lista e os baralhos que elas sugerem. Isto servirá para montar uma base de dados para fazermos outras análises posteriormente.
author:
  - first_name: Nicholas 
    last_name: Marino
    url: https://github.com/nacmarino
date: 11-16-2021
categories:
  - web scraping
  - boardgames
output:
  distill::distill_article:
    self_contained: false
    toc: true
    code_folding: true
    highlight: rstudio
draft: true
---

```{r setup, include=FALSE}
# setando as opções gerais dos code chunks
knitr::opts_chunk$set(echo = FALSE, code_folding = FALSE, fig.align = 'center')

# carregando o ggplot2
library(ggplot2)

# setando o tema geral do ggplot2
theme_set(new = theme_minimal(base_family = 'Roboto'))

# atualizando o tema
theme_update(
  plot.title    = element_text(face = 'bold', size = 10),
  plot.subtitle = element_text(size = 8),
  plot.caption  = element_text(size = 8),
  axis.title    = element_text(face = 'bold', size = 8),
  axis.text     = element_text(color = 'black', size = 8),
  strip.text    = element_text(face = 'bold', size = 8)
)
```

# Motivação

The Witcher é uma franquia lançada como uma série de livros de fantasia que contam as aventuras do bruxo (_i.e._, Witcher) Geralt de Rivia. Essas estórias foram popularizadas através da série da Netflix de mesmo nome e, também, através do jogo para _videogames_ The Witcher 3: The Wild Hunt^[Um dos jogos mais _tops_ que já joguei.]. Esse jogo é bastante complexo e tem uma experiência bastante imersiva, trazendo inclusive diversas tradições do universo à ela. Uma delas é o Gwent, um jogo de cartas entre dois jogadores, onde ganha aquele que mais pontuar em pelo menos 2 de 3 turnos. Parece ser um mini-jogo bobo dentro do título, mas ele próprio invoca muito da fantasia da série na disputa.

Gwent é um jogo que lembra muito o Magic, onde você deve construir um baralho de no mínimo 25 cartas pertencentes à uma facção de sua escolha, respeitando algumas restrições (_e.g._, custo total das cartas no baralho, quantidade de unidades,...). No momento em que escrevo este _post_, existem cerca de 200 cartas pertencentes à cada uma de 6 facções distintas, além de outras 200 à 400 cartas neutras (_i.e._, que não pertencem à nenhuma facção) que podem ser usadas para montar um baralho. Existe uma diferença inerente ao modo de jogar com cada facção (_e.g._, foco em dano direto, foco bloqueio e roubo de cartas,...) e, dentro de uma dada facção, também existe uma pequena diversidade de formas de montar o baralho de forma a fortificar uma estratégia (_e.g._, cartas que juntas reforçam muito umas as outras, cartas que ajudam a ativar a habilidade de outras cartas mais frequentemente). Neste sentido, montar um baralho forte e consistente passa a ser quase uma arte, mas que poderia ser aprimorado com um pouquinho mais de orientação baseada em dados.

Existe bastante conteúdo na internet que é produzido pela própria comunidade que joga o Gwent. Em particular, a própria comunidade contribui compartilhando a composição de cartas nos seus baralhos, as estratégias de jogo e votando nestas a partir do próprio site oficial do jogo. E é aqui que entra o meu interesse, pois se pudermos obter estas informações e estruturá-las, ficaria muito mais fácil entender os padrões dentro e entre os baralhos e usar isso em favor de aprimorar a jogabilidade. Além disso, acredito que estes dados podem dar um bom modelo de estudo para responder à algumas perguntas e praticar algumas outras técnicas. Falarei sobre essas idéias ao final do _post_, mas por agora vou mostrar como obter essas informações.

# Raspando um deck

A página principal dos decks disponíveis no site oficial do jogo pode ser acessada através da _url_ https://www.playgwent.com/pt-BR/decks, ou clicando nesse [link](https://www.playgwent.com/pt-BR/decks). Assim que a página abrir, já é possível ver que os decks estão organizados em uma espécie de tabela, com diversas informações sobre eles, tais como a quantidade de votos, nome, autor, custo de fabricação e etc. Além disso, existem diversos filtros e opções de interatividade na página, como os filtros de facção, habilidade do líder, melhores baralhos e etc. Vamos voltar à essa _landing page_ em breve mas, por enquanto, vamos selecionar um baralho qualquer e clicar em seu nome para ir até a sua página.

```{r img_landing_page, layout = 'l-body-outset', code_folding = TRUE}
knitr::include_graphics(path = 'images/imagem_1.jpg')
```

Chegamos à página do deck, cuja _url_ parece sugerir que a paginação de cada um deles deve seguir o padrão de uma _url_ base (_i.e._, https://www.playgwent.com/pt-BR/decks/guides/) seguida de uma numeração que representa o identificador único do deck. Outra coisa que já é notável é que muitas das informações que estavam disponíveis na página anterior também estão repetidas aqui. No entanto, podemos ver que agora existe (em alguns casos) uma descrição do deck, a estratégia de uso do deck e, o mais importante, uma lista das cartas que o compõem. É esta lista que queremos pegar.

```{r img_identificar_deck, layout = 'l-body-outset', code_folding = TRUE}
knitr::include_graphics(path = 'images/imagem_3.jpg')
```

Se passarmos o cursor em cima das cartas, podemos ver que vai aparecer um _tooltip_ com a imagem da carta e a descrição dela. Isto parece sugerir que deve existir algum tipo de linguagem dinâmica atuando por trás dos panos, o que poderia complicar a vida do nosso _scrapper_. Mas o que será que está alimentando esse conteúdo dinâmico dentro da página? Se formos na ferramenta `Inspecionar` do navegador e olharmos o próprio código HTML da página, veremos que existe uma quantidade enorme de texto dentro de uma _tag_, organizada de uma forma que lembra muito um dicionário no Python ou um arquivo JSON. Para achar esse texto, basta procurar uma _tag_ _div_ da classe `wrapper`, buscar dentro dela uma outra _tag_ _div_ da classe `content` e, mais uma vez, uma _tag_ _div_ com o id `root`; a partir daí, todo o dicionário pode ser acessado olhando o atributo `data-state`. Ou seja, não é que o conteúdo da página seja dinâmica, só a forma como ele é mostrado mesmo.

```{r img_entender_deck, layout = 'l-body-outset', code_folding = TRUE}
knitr::include_graphics(path = 'images/imagem_4.jpg')
```

Com esse entendimento, vamos então começar a atividade de raspar esse deck. Vou criar uma função que ficará responsável por fazer um `GET` da página do deck, uma vez que o seu código numérico de identificação seja passado. Essa função também salvará essa página HTML em um algum _path_ especificado e, antes de concluir, vai hibernar por 1 ou 2 segundos^[Esse passo não é obrigatório, mas decidi colocá-lo aqui só para não bombardear o servidor de _request_ uma vez que eu vá usar essa função dentro de um `map`.]

```{r funcao_scrape_deck}
## carregando os pacotes
library(tidyverse) # core
library(httr) # para fazer o web scrapping
library(xml2) # para ajudar a parsear
library(fs) # para manipular os paths

## para raspar um deck
scrape_deck <- function(deck_id, path_to_save) {
  ## fazendo o request e salvando em disco
  GET(
    url = str_glue('https://www.playgwent.com/pt-BR/decks/guides/{deck_id}'), 
    write_disk(path = sprintf(fmt = '%s/deck_%06d.html', path_to_save, deck_id), 
               overwrite = TRUE)
  )
  Sys.sleep(time = runif(n = 1, min = 1, max = 2))
}
```

Vamos usar agora essa função para baixar o deck da tela e salvá-lo em disco.

```{r get_um_deck}
# setando o path local para salvar o HTML do deck
path_decks <- 'gwent_decks/'
# path_decks <- '_posts/2021-11-16-raspando-a-lista-de-baralhos-de-gwent/gwent_decks/'

# criando um diretorio local para salvar o HTML do deck caso nao exista
if(!dir_exists(path = path_decks)){
  dir_create(path = path_decks, recurse = TRUE)
}

# baixando um deck usando a funcao criada
scrape_deck(deck_id = 280934, path_to_save = path_decks)
```

Deck baixado! Vamos agora criar uma função para fazer uma primeira etapa do parser dele, onde a ideia vai ser tirar o dicionário que se parece com o JSON de dentro do código HTML e deixá-lo mais próximo de ser usado para pegar a lista de cartas. A função receberá como input o path até o deck salvo em disco, buscará o JSON e fará uma organização dos dados para extrair apenas a chave relacionada às informações das cartas do deck.

```{r funcao_deck_to_json}
# para parsear o html do deck para o json
deck_to_json <- function(path_para_deck) {
  # lendo o arquivo salvo como html
  read_html(x = path_para_deck) %>% 
    # pegando o xpath onde está o dicionario json
    xml_find_all(xpath = '//div[@class="wrapper"]//div[@class="content"]//div[@id="root"]') %>% 
    # pegando o atributo do dicionario
    xml_attr(attr = 'data-state') %>% 
    # parseando o json
    jsonlite::fromJSON(simplifyDataFrame = TRUE) %>% 
    # pegando o guide
    pluck('guide') %>% 
    # passando tudo para um dataframe
    enframe %>% 
    # pegando so o deck
    filter(name == 'deck') %>% 
    # desaninhando a list column
    unnest(value) %>% 
    # pegando os valores
    pull(value)
}
```

Se testarmos a função para parsear o JSON do deck, veremos que o seu output é uma lista, e que cada elemento dessa lista é uma informação diferente sobre o deck - não só a lista de cartas em si. Ou seja, precisamos agora parsear e organizar as informações da lista.

```{r}
# parseando o codigo de HTML para algo parecido com um JSON
jsonfied_deck <- deck_to_json(path_para_deck = dir_ls(path = path_decks, recurse = TRUE))
sprintf('Classe do objeto parseado: %s. Quantidade de elementos na lista: %s.', 
        class(jsonfied_deck), length(jsonfied_deck))
```

Uma coisa importante antes de prosseguir é entender um pouco sobre a estrutura básica de um deck de Gwent e a forma como ele é apresentado originalmente na página:

+ O banner no topo do deck representa a habilidade do líder que deve ser usada. Cada facção oferece umas 6 habilidades diferentes, mas específicas para cada uma delas;  
+ A carta logo abaixo do banner representa a carta de estratégia que deve ser usada junto ao deck. Existem algumas cartas de estratégia disponíveis, algumas das quais são específicas para certas facções, outras neutras. De uma forma ou de outra, todo deck tem também a sua carta de estratégia;  
+ Tudo o que vier depois destes dois, representam as cartas que compõem o deck _per se_. Um deck é montado usando no mínimo 25 cartas, com mais algumas regrinhas relacionadas ao custo das cartas e quantidade de cartas de um tipo específico. Além disso, podem haver cópias de algumas cartas no deck, que são representadas pela tag `x2` ao lado de cada carta.  

Tendo essa visão em mente, precisamos então das informações das cartas do deck, da carta de estratégia e da habilidade do líder a fim de que possamos reproduzir o deck que está na página. Se voltarmos à lista obtida depois que parseamos o deck para algo parecido com um JSON, podemos ver que existem três elementos distintos, cada um deles para um desses tipos de informação: `cards` (_i.e._, lista de cartas no deck), `stratagem` (_i.e._, carta de estratégia) e `leader` (_i.e._, a habilidade do líder). Além disso, existe uma informação importante para cada um destes itens e para cada carta em `cards` que precisaremos estar atentos: as informações do texto de descrição da carta que aparece no `tooltip`. Esse `tooltip` é uma lista de listas (de listas, em alguns casos), e tratá-lo junto dos demais metadados seria bastante doloroso. Neste contexto, vamos parsear as informações que estão no `tooltip` separado daquelas dos metadados de de cada elemento, e os juntaremos posteriormente.

A função abaixo dá conta de fazer o parser dos metadados associados à cada elemento. Nos testes que fiz, reparei que a forma como os metadados do elemento `cards` está organizado é diferente daquele dos outros dois elementos, `stratagem` e `leader`, mas que a estrutura destes dois é bastante similar. Assim, juntei esse parser em uma função só, usando um `if` para dizer se o processamento deve ser específico a um grupo ou outro de elementos. Além disso, aproveitei para numerar as cartas na sequência em que elas aparecem: habilidade do líder (_i.e._, ID numérico -1), carta de estratégia (_i.e._, ID numérico 0) e todas as demais cartas (_i.e._, ID numérico 1 ao número de cartas no deck).

```{r funcao_parser_card_metadata}
# para parsear os metadados de cada carta
parser_card_metadata <- function(deck_json_file, card_type = c('cards', 'stratagem', 'leader')) {
  # pegando os metadados da carta
  card_metadata <- deck_json_file %>% 
    # selecionando o tipo de carta
    pluck(card_type[1]) %>% 
    # descartando informacoes que nao precisamos
    discard(names(.) %in% c('slotImg', 'slotImgCn', 'previewImg', 'previewImgCn', 
                            'thumbnailImg', 'thumbnailImgCn', 'abilityImg', 
                            'abilityImgCn', 'tooltip')) 
  # parseando cards
  if(card_type[1] == 'cards') {
    card_metadata %>% 
      as_tibble() %>% 
      unpack(cols = faction) %>% 
      add_column(card_in_seq = 1:nrow(.), .before = 'craftingCost')
  # parseando cartas de estrategia ou habilidade do lider
  } else {
    card_metadata %>% 
      bind_cols() %>% 
      suppressWarnings() %>% 
      mutate(card_in_seq = if(card_type[1] == 'leader') {-1L} else {0L}) %>% 
      relocate(card_in_seq, .before = craftingCost)
  }
}
```

Falar do parser do tooltip.

```{r funcao_parser_card_tooltip}
# para fazer o parser do tooltip de cada carta
parser_card_tooltip <- function(deck_json_file, card_type = c('cards', 'stratagem', 'leader')) {
  
  # procedimento para pegar os dados do tooltip para a carta de habilidade lider
  if(card_type[1] == 'leader') {
    # pegando o tooltip da habilidade do lider e juntando tudo em um tibble so
    tooltip_data <- deck_json_file %>% 
      pluck('leader', 'tooltip') %>% 
      map(.f = bind_rows) %>% 
      bind_rows() 
    # procedimento para pegar os dados do tooltip para as cartas normais ou de estrategia
  } else {
    tooltip_data <- deck_json_file %>% 
      pluck(card_type[1], 'tooltip') %>% 
      map(.f = bind_rows) %>% 
      enframe(name = 'card_in_seq') %>% 
      unnest(cols = c(value)) %>% 
      group_by(card_in_seq) 
  }
  
  # summarizando os dados de cada tooltip para cada carta
  tooltip_data <- tooltip_data %>% 
    summarise(
      keywords = paste0(unique(str_to_lower(string = key[!is.na(key)])), collapse = ';'),
      texto    = paste0(value, collapse = ' ')
    ) %>% 
    # tratando o texto do tooltip
    mutate(
      keywords = ifelse(test = keywords == '', yes = NA, no = keywords),
      keywords = str_to_lower(string = keywords),
      texto = str_replace_all(string = texto, pattern = '\\s+', replacement = ' '),
      texto = str_replace_all(string = texto, pattern = '\\s:', replacement = ':'),
      texto = str_replace_all(string = texto, pattern = '(?<=\\()\\s|\\s(?=\\))', replacement = ''),
      texto = str_replace_all(string = texto, pattern = '\\s(?=\\.)|\\s(?=\\,)', replacement = ''),
    )
  
  # adicionando identificador numerico para a carta do tooltip e retornando o resultado
  if(card_type[1] == 'cards') {
    tooltip_data
  }
  else{
    mutate(tooltip_data,
           card_in_seq = if(card_type[1] == 'leader') {-1L} else {0L}
    ) %>% 
      relocate(card_in_seq, .before = keywords)
  }
}
```

Testar o parser consolidando em uma unica funcao.

```{r funcao_parser_card}
# para parsear todas as informacoes do deck
parser_cards <- function(path_para_deck) {
  # parseando o json do deck
  target_deck <- deck_to_json(path_para_deck = path_para_deck)
  
  # pegando os tooltips de todas as cartas
  tooltips <- map_dfr(.x = c('leader', 'stratagem', 'cards'),
                      .f = parser_card_tooltip,
                      deck_json_file = target_deck)
  
  # pegando os metadados de todas as cartas
  metadados <- map_dfr(.x = c('leader', 'stratagem', 'cards'),
                       .f = parser_card_metadata,
                       deck_json_file = target_deck)
  
  left_join(x = metadados, y = tooltips, by = 'card_in_seq')
}
```

Vamos testar o parser do deck.

```{r parser_um_deck, layout = 'l-body-outset'}
# parseando o deck
parsed_deck <- parser_cards(path_para_deck = dir_ls(path = path_decks, recurse = TRUE))
# visualizando a tabela do deck
rmarkdown::paged_table(x = parser_cards(path_para_deck = dir_ls(path = path_decks, recurse = TRUE)))
```

Concluir que agora precisamos de mais decks. Para isso, vamos raspar a lista para pegar o id dos decks.

# Raspando a lista de decks

Voltar para a landing page e falar que não tem paginação, que o conteúdo parece ser gerado dinamicamente.

```{r img_identificar_lista, layout = 'l-body-outset', code_folding = TRUE}
knitr::include_graphics(path = 'images/imagem_1.jpg')
```

Mostrar que se abrir o network, vai ver que tem uma API escondida.

```{r img_entender_lista, layout = 'l-body-outset', code_folding = TRUE}
knitr::include_graphics(path = 'images/imagem_2.jpg')
```

Falar do scrapper da lista.

```{r funcao_scrape_lista, eval = FALSE}
## para raspar uma lista
scrape_lista <- function(pagina, listas_por_pagina, path_to_save) {
  ## calculando o offset atraves da pagina que deseja-se pegar
  offset <- (pagina * listas_por_pagina) - listas_por_pagina
  ## fazendo o request e salvando em disco
  GET(
    url = str_glue('https://www.playgwent.com/pt-BR/decks/api/guides/offset/{offset}/limit/{listas_por_pagina}'), 
    write_disk(path = sprintf(fmt = '%s/pagina_%06d.json', path_to_save, pagina), overwrite = TRUE)
  )
  Sys.sleep(time = runif(n = 1, min = 1e-2, max = 1))
}
```

Falar do uso escalando.

```{r get_listas, eval = FALSE}
# criar diretorio e baixar umas 5 paginas da lista, aumentando o limit.
```

Falar da funcao do parser da lista.

```{r funcao_parser_lista, eval = FALSE}
## para parseaar uma lista
parser_lista <- function(path_para_lista) {
  # carregando os dados como um json
  read_json(path = path_para_lista, simplifyDataFrame = TRUE) %>% 
    # pegando so o elemento da lista que sejam os guides
    pluck('guides') %>% 
    # passando para tibble
    as_tibble() %>% 
    # desempacotando o dataframe column para multiplas colunas
    unpack(cols = faction) %>% 
    # jogando fora o que nao interessa
    select(-c(short, thumbnailImg, abilityImg))
}
```

# Qual a tendência do momento?

Mostrar análise do tipo de deck, custo da carta, votos, datas de contribuição e modificação.

# Conclusões

# Possíveis Extensões
