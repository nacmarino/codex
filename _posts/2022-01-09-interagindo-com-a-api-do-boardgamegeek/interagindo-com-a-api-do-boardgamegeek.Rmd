---
title: "Interagindo com a API do BoardGameGeek"
description: |
  A short description of the post.
author:
  - first_name: Nicholas 
    last_name: Marino
    url: https://github.com/nacmarino
date: 01-17-2022
categories:
  - web scraping
  - boardgames
output:
  distill::distill_article:
    self_contained: false
    toc: true
    code_folding: true
    highlight: rstudio
draft: true
---

```{r setup, include=FALSE}
# setando as opções gerais dos code chunks
knitr::opts_chunk$set(echo = FALSE, code_folding = FALSE, cache = TRUE, dpi = 200, fig.align = 'center')

# presetando o ggplot2
library(ggplot2)

# setando o tema geral do ggplot2
theme_set(new = theme_minimal(base_family = 'Nunito'))

# atualizando o tema
theme_update(
  plot.title    = element_text(face = 'bold', size = 10),
  plot.subtitle = element_text(size = 8),
  plot.caption  = element_text(size = 8),
  axis.title    = element_text(face = 'bold', size = 8),
  axis.text     = element_text(color = 'black', size = 8),
  strip.text    = element_text(face = 'bold', size = 8)
)
```

# Motivação

Um dos primeiros [posts](https://nacmarino.github.io/codex/posts/2021-09-17-raspando-a-pgina-do-ranking-do-boardgamegeek/) do blog foi sobre um _scrapper_ para obtermos as informações da página do ranking do [BoardGameGeek](https://boardgamegeek.com/browse/boardgame), um portal especializado em jogos de tabuleiro. Meu principal objetivo com isso não foi o de extrair o ranking em si, mas o de obter o identificador único de cada jogo para usá-lo junto à API XML oferecida pelo portal. Essa API nos dá acesso à (praticamente) todas as informações sobre os jogos que estão disponíveis em suas respectivas páginas e, portanto, fornece um caminho mais simples para obtermos os dados sobre cada um deles de forma programática. No entanto, o mais importante para mim é que as informações vindas dessa API têm o potencial de facilitar uma das coisas que eu mais tenho dificuldade: encontrar os jogos que combinam com aquilo que eu curto.

Neste post eu mostro como interagir com a API XML do BGG e, também, fazer o _parser_ das informações que obtemos a partir dela. Esse processo vai ser importante para entendermos os tipos de dados que temos disponíveis e as possíveis formas de usá-los nos próximos posts.

# Funcionamento da API

A primeira coisa que precisaremos fazer para interagir com a API do BGG é carregar a base que contém o identificador único de cada jogo. Estes dados podem ser obtidos a partir do _scrapper_ disponível neste [link](https://nacmarino.github.io/codex/posts/2021-09-17-raspando-a-pgina-do-ranking-do-boardgamegeek/), ou você pode simplesmente usar a base de dados disponível junto a esse post. A informação que precisaremos esta na tabela abaixo, e são os números que estão na coluna `id`.

```{r carrega_dados}
# carregando os pacotes
library(tidyverse) # core
library(httr) # para fazer o scraping
library(xml2) # para o parser
library(fs) # para manipular paths

## lendo os dados do ranking da BGG para pegar o identificador unico de cada jogo
ranking <- read_rds(file = 'data/ranking_bgg.rds') %>% 
  # dropando os jogos que não possuem game_id
  drop_na(id)
# ranking <- read_rds(file = '_posts/2022-01-09-interagindo-com-a-api-do-boardgamegeek/data/ranking_bgg.rds') %>%
#   drop_na(id)

## visualizando a tabela
rmarkdown::paged_table(x = ranking)
```

A API do BGG funciona através de requisições do tipo `GET`, que retornam um arquivo `xml` (e**X**tensible **M**arkup **L**anguage) cujos parâmetros e valores seguem o padrão de _tags_ e atributos comum à páginas `HTML`. Acredito que essa API não segue a arquitetura do tipo REST (**RE**presentational **S**tate **T**ransfer), uma vez que (1) as requisições para um determinado tipo de informação são todas feitas através de um único _endpoint_ e (2) os nomes dos métodos utilizados devem ser passados diretamente para a `url` da requisição. De toda forma, essa API é bastante simples de usar - mas mais trabalhosa de _parsear_, como veremos mais adiante.

Existem diversos tipos de informação disponíveis no site do BGG que podem ser obtidas através dessa API, tais como os dados dos jogos (_i.e._, `thing`), das coleções (_i.e._, `collection`) e dos próprios usuários (_i.e._, `user`) e do fórum (_i.e._, `forum`). Além disso, dentro de cada tipo de informação desta, podemos buscar detalhes específicos, tais como tudo o que há no _marketplace_ para um jogo ou os resultados das partidas dos jogos registrados por cada usuário. Apesar desse existir esse monte de informação disponivel, neste post vamos focar apenas as informações dos jogos e, portanto, vamos usar o _endpoint_ `https://www.boardgamegeek.com/xmlapi2/thing` - a documentação da API pode ser encontrada [aqui](https://boardgamegeek.com/wiki/page/BGG_XML_API2). 

Existem diversos métodos que podemos ser usados junto daquele _endpoint_. Os métodos que vamos usar aqui são o `id` do jogo (que vamos extrair da tabela que carregamos acima), as estatísticas relacionadas à cada jogo (setando `stats=1`) e uma amostra de, no máximo, 100 comentários associados à cada jogo (setando `ratingcomments=1` e `pagesize=100`). Existem outros métodos associados a esse _endpoint_, como os vídeos que falam sobre o jogo (_i.e._, `videos=1`) e as informações dos anúncios do _marketplace_ (_i.e._, `marketplace=1`), mas não vamos trabalhar com eles aqui. De toda forma, precisamos juntar o endereço do _endpoint_ e os método para compor a `url` para do `GET`: para isso, vamos separar o _endpoint_ dos métodos utilizando o `?` e cada método do outro usando o `&`. Com isso, a `url` ficará assim: `https://www.boardgamegeek.com/xmlapi2/thing?id=<game_id>&stats=1&ratingcomments=1&pagesize=100` - onde o `game_id` vai ser um número correspondente ao identificador numérico do jogo. 

A função abaixo cuidará de fazer essa requisição, salvando uma cópia do HTML da resposta em disco caso o valor passado para o argumento `path_to_save` não seja `NULL`.

```{r funcao_pega_jogo}
## funcao para pegar o XML de um jogo
pega_jogo <- function(game_id, path_to_save = NULL) {
  # url base para pegar um jogo, as estatisticas e a primeira pagina de comentarios
  base_url <- str_glue('https://www.boardgamegeek.com/xmlapi2/thing?id={game_id}&stats=1&ratingcomments=1&pagesize=100')
  
  # fazendo o request e salvando o codigo da resposta se o path nao for nulo
  if(!is.null(path_to_save)){
    GET(url = base_url, 
        write_disk(path = sprintf(fmt = '%s/%08d.html', path_to_save, game_id), 
                   overwrite = TRUE)
    )
  } else {
    GET(url = base_url)
  }
  
}
```

Vamos usar a função para fazer a requisição de um jogo, salvando o `xml` resultante em disco. Antes disso, vou criar um diretório temporário para armazenar o `xml` e, também, extrair o identificador numérico do jogo que utilizaremos nesse exemplo: o __Ticket to Ride__. Esse é um jogo de construir rotas com trenzinhos, e é muito legal e divertido. 

```{r pega_um_jogo}
## setando o path onde vamos jogar os arquivos
path_scrapped_data <- 'temporario'
# path_scrapped_data <- '_posts/2022-01-09-interagindo-com-a-api-do-boardgamegeek/temporario'

## criando pasta se ela nao existir
if(!dir_exists(path_scrapped_data)){
  dir_create(path = path_scrapped_data, recurse = TRUE)
}

# pegando o id do jogo que vamos usar no exemplo
id_do_jogo <- ranking %>% 
  # pegando o jogo wingspan
  filter(titulo == 'Ticket to Ride') %>% 
  # pegando o id do jogo
  pull(id) %>% 
  # parseando o id para um numero
  parse_number()

# fazendo o request do XML do jogo
xml_do_jogo <- pega_jogo(game_id = id_do_jogo, path_to_save = path_scrapped_data)
```

Podemos pegar o `content` da resposta da requisição e usar a função `xml_structure` para entender a sua estrutura. Isso nos ajuda bastante a identificar as _tags_ que precisamos buscar, bem como o tipo de resultado que deve estar associado à cada uma delas. Como o output dessa função é bastante longo, resolvi usar outra abordagem aqui no post só para dar uma ideia do que existe dentro da resposta: usei a função `as_list` do pacote `xml2` para parsear o código para uma lista do R e, então, usei a função `pluck` para catar os elementos que realmente importam para nós - eles são uma uma lista dentro da lista `item` que está dentro da lista `items`; depois disso, usei a função `names` para extrair os nomes de cada _tag_ e, como o resultado também era longo, passei o vetor de _strings_ para a função `table`. O resultado que obtemos com isso é apresentado abaixo, onde podemos ver quantas vezes cada _tag_ aparece dentro do `xml`. Como podemos ver, existem _tags_ que são ok de entender o que é e pegar, mas tem outras _tags_ que possivelmente nos darão uma dose extra de trabalho (_i.e._, `links`, `name` e `pool`).

```{r estrutura_do_xml}
xml_do_jogo %>% 
  # pega o conteudo da response
  content() %>% 
  # coloca o conteudo como uma lista
  as_list() %>% 
  # pega os elementos da lista que estao dentro de item
  pluck('items', 'item') %>% 
  # olha os nomes dos elementos na sublista
  names %>% 
  # contando quantas vezes cada nome aparece
  table
```

Vamos parsear cada um desses resultados a seguir.

# Parseando o `response`

A primeira informação que vamos parsear é àquela que está dentro da _tag_ `name`. Para isso, precisaremos pegar tudo o que está associado à essa _tag_ e extrair os atributos de cada elemento com `xml_attrs`. O resultado dessa operação é uma lista onde cada elemento dela é um `data.frame` com uma única linha, contendo um nome do jogo e um indicador se esse nome é o oficial (_i.e._, _primary_) ou o não-oficial (_i.e._, _alternate_). A partir daí juntaremos essas linhas usando um `bind_rows` seguido de um `select` para organizar o resultado. Aplicando essa função ao conteúdo do `xml`, obtemos uma tabelinha com todos os nomes do jogo, onde podemos ver que o os nomes não-oficiais são normalmente aqueles em outras línguas. Essa tabela é bastante útil pois, com base nela, podemos fazer um de-para das informações do BGG para àquelas da [Ludopedia](https://www.ludopedia.com.br/ranking), o que nos permite responder à algumas perguntas que havíamos aberto [anteriormente](https://nacmarino.github.io/codex/posts/2021-12-11-quao-similares-sao-as-notas-dos-jogos-de-tabuleiro-entre-os-portais-especializados/).

```{r funcao_parser_nome}
## funcao para parsear a lista de nomes do jogo
parser_nome <- function(arquivo_xml) {
  # pega o arquivo HTML
  arquivo_xml %>% 
    # extrai todas as tags name
    xml_find_all(xpath = '*//name') %>% 
    # extrai todo os atributos dessas tags
    xml_attrs() %>% 
    # junta todos os atributos em uma tibble
    bind_rows() %>% 
    # remove a coluna sortindex
    select(titulo = value, metadado = type)
}

# parseando os nomes
parser_nome(arquivo_xml = content(x = xml_do_jogo))
```

A próxima informação que vamos parsear é a descrição do jogo. Como poderíamos esperar, essa informação é um texto disponível dentro da _tag_ `description`. O resultado do _parser_ é um string bastante longo, com toda a estorinha e contexto sobre o jogo.

```{r funcao_parser_descricao}
## funcao para parsear a descricao do jogo
parser_descricao <- function(arquivo_xml) {
  # pega o arquivo HTML
  arquivo_xml %>% 
    # extrai todas as tags description
    xml_find_first(xpath = '*//description') %>% 
    # extrai o texto da descricao
    xml_text()
}

# parseando a descricao
parser_descricao(arquivo_xml = content(x = xml_do_jogo))
```

A próxima função faz o _parser_ de diversas informações relacionadas às especificações técnicas de cada jogo, e coloca tudo dentro de colunas distintas de um `tibble`. Essas informações falam do ano de publicação do jogo, quantidade de jogadores, tempo de jogo e idade mínima. Deu um trabalhinho fazer esse _parser_ em uma função só, pois todas essas coisas estão em _tags_ diferentes e, portanto, precisei user o `self` dentro do _xpath_.

```{r funcao_parser_informacoes}
## funcao para parsear as informacoes do jogo
parser_informacoes <- function(arquivo_xml) {
  # pega o arquivo HTML
  arquivo_xml %>% 
    # extrai todas as tags relacionadas às informações sobre o ano de publicacao, quantidade de jogadores
    # idade minima para o jogo e tempo de jogo
    xml_find_all(xpath = '*//*[self::yearpublished or self::minplayers or self::maxplayers
               or self::playingtime or self::minplaytime or self::maxplaytime or self::minage]') %>% 
    # colocando todos os atributos dessa tag em um tibble
    map_dfr(
      ~ list(
        caracteristica = xml_name(.x),
        valor = xml_attrs(.x, 'value')
      )) %>% 
    # parseando tudo para numerico
    mutate(valor = parse_number(x = valor)) %>% 
    # passando o tibble do formato longo para o largo
    pivot_wider(names_from = caracteristica, values_from = valor)
}

# parseando as informacoes
parser_informacoes(arquivo_xml = content(x = xml_do_jogo))
```

Quando passamos o método `stats=1` para o _endpoint_ também coletamos as informações sobre as estatísticas relacionadas ao _ranking_ para o jogo que escolhemos. Com isso vamos ter acesso à dois principais aspectos: as informações relativas às notas e àquelas diretamente relacionadas aos _rankings_ em que cada jogo aparece. A função abaixo dá conta de parsear o primeiro destes, nos dando acesso à quantidade de votos que cada jogo recebeu, a nota média (arimética e bayesiana), além da quantidade de usuários que têm o jogo, estão trocando, querem ou o desejam.

```{r funcao_parser_avaliacoes}
## funcao para parsear todas as informacoes relacionadas à avaliação de cada jogo
parser_avaliacoes <- function(arquivo_xml) {
  # extrai outras informacoes das avaliacoes e junta com as informacoes de rankings e contagem de comentarios
  arquivo_xml %>% 
    # extrai todas as tags relacionadas dentro das avaliacoes que nao estejam relacionadas ao rankeamento
    xml_find_all(xpath = '*/statistics/ratings/*[not(self::ranks)]') %>% 
    # coloca todas as informacoes dentro de um tibble
    map_dfr(
      ~ list(
        estatistica = xml_name(.x),
        valor = xml_attrs(.x, 'value')
      )
    ) %>% 
    # parseando tudo para numerico
    mutate(valor = parse_number(x = valor)) %>% 
    # passando o tibble do formato longo para o largo
    pivot_wider(names_from = estatistica, values_from = valor)
}

# parseando as avaliacoes
parser_avaliacoes(arquivo_xml = content(x = xml_do_jogo))
```

Já a função abaixo parseia os _rankings_ em que cada jogo aparece. Além do _ranking_ geral, cada jogo também pode estar posicionado dentro da família de jogos à que pertence e/ou aos tipos de mecânica associados a ele. No nosso exemplo, podemos ver que o _Ticket to Ride_ ocupa a 193º posição do _ranking_ geral e a 40º posição quando o assunto são os jogos familiares.

```{r funcao_parser_rankings}
## funcao para parsear todas as informacoes relacionadas aos rankings em que cada jogo esta
parser_rankings <- function(arquivo_xml) {
  # pega o arquivo html
  arquivo_xml %>% 
    # extrai todas as tags que estejam relacionadas ao ranking
    xml_find_all(xpath = '*/statistics/ratings/ranks/rank') %>% 
    # extrai todo os atributos dessas tags
    xml_attrs('value') %>% 
    # junta todos os atributos em uma tibble
    bind_rows() %>% 
    # renomeando colunas
    rename(nivel = type, tipo = name, nome = friendlyname, 
           posicao = value, media_bayesiana = bayesaverage) %>% 
    # parseando os numericos para tal
    mutate(
      posicao         = parse_number(x = posicao),
      media_bayesiana = parse_number(x = media_bayesiana)
    )
}

# parseando os rankings
parser_rankings(arquivo_xml = content(x = xml_do_jogo))
```

Parseia os comentarios sobre o jogo.

```{r funcao_parser_comentarios}
## funcao para parsear os comentarios sobre o jogo
parser_comentarios <- function(arquivo_xml) {
  # pega o arquivo HTML
  arquivo_xml %>% 
    # extrai todas as tags de comentario
    xml_find_all(xpath = '*/comments/comment') %>% 
    # extrai todo os atributos dessas tags
    xml_attrs('value') %>% 
    # junta todos os atributos em uma tibble
    bind_rows() %>% 
    # renomeando as colunas
    rename(usuario = username, nota = rating, comentario = value) %>% 
    # parseando as notas para numerico
    mutate(nota = parse_number(x = nota))
}

# parseando os comentarios
parser_comentarios(arquivo_xml = content(x = xml_do_jogo))
```

Parseia o total de comentários do jogo.

```{r funcao_parser_comentarios_total}
## funcao para parsear a quantidade total de comentarios que um jogo tem
parser_comentarios_total <- function(arquivo_xml) {
  # pega o arquivo html
  arquivo_xml %>% 
    # pega tudo o que está sobre a tag comments
    xml_find_all(xpath = '*/comments') %>% 
    # pega apenas o valor correspondente ao total de comentarios
    xml_attr('totalitems') %>% 
    # parseando o string para numero
    parse_number()
}

# parseando a descricao
parser_comentarios_total(arquivo_xml = content(x = xml_do_jogo))
```

Parseia o resultado da votacao da melhor quantidade de jogadores do jogo.

```{r funcao_parser_votacao_n_jogadores}
## funcao para parsear os resultados da votacao do melhor numero de jogadores para se jogar
parser_votacao_n_jogadores <- function(arquivo_xml) {
  # pega o arquivo html
  arquivo_xml %>% 
    # extrai todas as tags com os resultados da votação relacionada ao melhor numero de jogadores
    xml_find_all(xpath = '*/poll[@name="suggested_numplayers"]/results') %>% 
    # coloca tudo dentro de um tibble
    map_dfr(
      ~ xml_find_all(.x, xpath = 'result') %>% 
        xml_attrs() %>% 
        bind_rows() %>% 
        mutate(numplayers = xml_attrs(.x))
    )  %>% 
    # renomeia e organiza as colunas
    select(num_jogadores = numplayers, voto = value, num_votos = numvotes) %>% 
    # parseando votos para numerico
    mutate(num_votos = parse_number(x = num_votos))
}

# parseando o resultado da votacao da melhor quantidade de jogadores
parser_votacao_n_jogadores(arquivo_xml = content(x = xml_do_jogo))
```

Parseia o resultado da votacao da melhor idade para o jogo.

```{r funcao_parser_votacao_idade}
## funcao para parsear os resultados da votacao da idade recomendada para o jogo
parser_votacao_idade <- function(arquivo_xml) {
  # pega o arquivo html
  arquivo_xml %>% 
    # extrai todas as tags com os resultados da votação relacionada à idade recomendada para o jogo
    xml_find_all(xpath = '*/poll[@name="suggested_playerage"]/results') %>% 
    # coloca tudo dentro de um tibble
    map_dfr(
      ~ xml_find_all(.x, xpath = 'result') %>% 
        xml_attrs()
    ) %>% 
    # renomeia e organiza as colunas
    select(idade_ideal = value, num_votos = numvotes) %>% 
    # parseando votos para numerico
    mutate(num_votos = parse_number(x = num_votos))
}

# parseando o resultado da votacao da melhor idade para o jogo
parser_votacao_idade(arquivo_xml = content(x = xml_do_jogo))
```

Parseia o resultado da votacao da dependencia do idioma para o jogo.

```{r funcao_parser_votacao_idioma}
## funcao para parsear os resultados da votacao sobre a dependencia do idioma para jogar o jogo
parser_votacao_idioma <- function(arquivo_xml) {
  # pega o arquivo html
  arquivo_xml %>% 
    # extrai todas as tags com os resultados da votacao sobre a dependencia do idioma para jogar o jogo
    xml_find_all(xpath = '*/poll[@name="language_dependence"]/results') %>% 
    # coloca tudo dentro de um tibble
    map_dfr(
      ~ xml_find_all(.x, xpath = 'result') %>% 
        xml_attrs()
    ) %>% 
    # renomeia e organiza as colunas
    select(voto = value, num_votos = numvotes) %>% 
    # parseando votos para numerico
    mutate(num_votos = parse_number(x = num_votos))
}

# parseando o resultado da votacao da dependencia do idioma
parser_votacao_idioma(arquivo_xml = content(x = xml_do_jogo))
```

Parseia os metadados do jogo.

```{r funcao_parser_metadados}
## funcao para parsear os metadados do jogo
parser_metadados <- function(arquivo_xml) {
  # pega o arquivo HTML
  arquivo_xml %>% 
    # extrai todas as tags link
    xml_find_all(xpath = '*//link') %>% 
    # extrai todo os atributos dessas tags
    xml_attrs() %>% 
    # junta todos os atributos em uma tibble
    bind_rows() %>% 
    # organiza as colunas
    select(id_metadado = id, metadado = value, tipo_metadado = type) %>% 
    # removendo o padrao boardgame do tipo de metadado
    mutate(tipo_metadado = str_replace(string = tipo_metadado, pattern = 'boardgame', replacement = 'tbl_')) %>% 
    # aninhando informacoes pelo tipo de metadado
    nest(data = -tipo_metadado) %>% 
    # passando o dado para o formato largo
    pivot_wider(names_from = tipo_metadado, values_from = data)
}

# parseando os metadados
parser_metadados(arquivo_xml = content(x = xml_do_jogo))
```

# Desempacotando os metadados

Desempacota os metadados em uma lista de tibbles.

```{r desempacota_metadados}
## expandindo cada uma das tabelas que contem multiplas informacoes sobre cada jogo
tabelas <- parser_metadados(arquivo_xml = content(x = xml_do_jogo)) %>% 
  # passando a base para o formato longo
  pivot_longer(cols = everything(), names_to = 'tabela', values_to = 'dados') %>% 
  # separando a base em listas de acordo com a dimensao
  split(.$tabela) %>% 
  # desaninhando cada tabela
  map(.f = unnest, cols = dados) %>% 
  # dropando a coluna do id da tabela
  map(.f = select, -tabela) %>% 
  # ordenando as tabelas por jogo em ordem alfabetica do metadado
  map(.f = arrange, metadado)
tabelas
```

Passa os metadados para o formato tidy.

```{r metadados_tidy}
## colocando as tabelas no formato tidy
tabelas_tidy <- tabelas %>% 
  # sumarizando todas as informacoes de forma a termos uma linha por jogo
  map(.f = summarise, metadado = paste0(unique(metadado), collapse = ';')) %>% 
  # colocando tudo em uma unica tabela
  bind_rows(.id = 'informacao') %>% 
  # removendo o prefixo tbl
  mutate(informacao = str_remove(string = informacao, pattern = 'tbl_')) %>% 
  # passando a base para o formato largo
  pivot_wider(names_from = informacao, values_from = metadado)
tabelas_tidy
```

# Colocando tudo junto

Parseando tudo de uma vez.

```{r funcao_parser_do_jogo}
# funcao para parsear o arquivo xml inteiro do jogo
parser_do_jogo <- function(path_arquivo_xml) {
  
  ## lendo o arquivo xml
  xml_do_jogo <- read_xml(x = path_arquivo_xml)
  
  ## parseando o arquivo xml
  tibble(
    tbl_nomes             = list(parser_nome(arquivo_xml = xml_do_jogo)),
    tbl_comentarios       = list(parser_comentarios(arquivo_xml = xml_do_jogo)), 
    tbl_rankings          = list(parser_rankings(arquivo_xml = xml_do_jogo)), 
    tbl_votacao_idade     = list(parser_votacao_idade(arquivo_xml = xml_do_jogo)), 
    tbl_votacao_idioma    = list(parser_votacao_idioma(arquivo_xml = xml_do_jogo)),
    tbl_votacao_jogadores = list(parser_votacao_n_jogadores(arquivo_xml = xml_do_jogo))
  ) %>% 
    # juntando informacoes que ja estao no formato esperado
    bind_cols(
      parser_metadados(arquivo_xml = xml_do_jogo),
      descricao = parser_descricao(arquivo_xml = xml_do_jogo),
      total_comentarios = parser_comentarios_total(arquivo_xml = xml_do_jogo),
      parser_avaliacoes(arquivo_xml = xml_do_jogo),
      parser_informacoes(arquivo_xml = xml_do_jogo)
    )
}

## fazendo o parser do jogo
jogos <- parser_do_jogo(path_arquivo_xml = 'temporario/00266192.html')
# jogos <- parser_do_jogo(path_arquivo_xml = '_posts/2022-01-09-interagindo-com-a-api-do-boardgamegeek/temporario/00266192.html')

## olhando a tabela
jogos
```

Criando a tabela final do jogo.

```{r jogo_formato_tidy}
## colocando a tabela com os jogos em um formato tidy
jogos_tidy <- jogos %>% 
  mutate(
    # extraindo nome oficial do jogo
    titulo  = map_chr(.x = tbl_nomes, 
                      .f = ~ filter(.x, metadado == 'primary') %>% pull(titulo)
    ),
    # codificando se o titulo é uma expansao ou nao
    eh_expansao = map2_int(.x = tbl_expansion, .y = titulo, .f = ~ any(.y %in% .x$metadado)),
    # pegando melhor idade
    idade_ideal = map_chr(.x = tbl_votacao_idade, 
                          .f = ~ filter(.x, num_votos == max(num_votos)) %>% 
                            pull(idade_ideal)
    ),
    # pegando melhor numero de jogadores
    melhor_n_jogadores = map_chr(.x = tbl_votacao_jogadores,
                                 .f = ~ filter(.x, voto == 'Best') %>% 
                                   filter(num_votos == max(num_votos)) %>% 
                                   pull(num_jogadores)
    ),
    # pegando pior numero de jogadores
    pior_n_jogadores = map_chr(.x = tbl_votacao_jogadores,
                               .f = ~ filter(.x, voto == 'Not Recommended') %>% 
                                 filter(num_votos == max(num_votos)) %>% 
                                 pull(num_jogadores)
    ),
    # pegando numero de jogadores recomendado
    recomendado_n_jogadores = map_chr(.x = tbl_votacao_jogadores,
                                      .f = ~ filter(.x, voto == 'Recommended') %>% 
                                        filter(num_votos == max(num_votos)) %>% 
                                        pull(num_jogadores)
    ),
    # pegando dependencia do idioma
    dependencia_do_idioma = map_chr(.x = tbl_votacao_idioma,
                                    .f = ~ filter(.x, num_votos == max(num_votos)) %>% 
                                      pull(voto)
    )
  ) %>% 
  # removendo todas as colunas que tenham como prefixo tbl
  select(-starts_with('tbl_')) %>% 
  # adicionando a base das tabelas no formato tidy
  bind_cols(tabelas_tidy) %>% 
  # colocando o titulo do jogo depois do id
  relocate(titulo, .before = descricao) %>% 
  # colocando as informacoes do numeroc de jogadores juntos
  relocate(melhor_n_jogadores, pior_n_jogadores, recomendado_n_jogadores, .after = maxplayers) %>% 
  # colocando informacoes da idade juntos
  relocate(idade_ideal, .after = minage) %>% 
  # renomeando as colunas
  rename(notas = usersrated, nota_usuarios = average, nota_bgg = bayesaverage,
         possuem = owned, trocam = trading, querem = wanting, desejam = wishing,
         ano_publicacao = yearpublished, artista = artist, categoria = category,
         edicoes_especiais = compilation, expansoes = expansion, familia = family,
         jogos_base = implementation, mecanica = mechanic, editora = publisher)
jogos_tidy
```


# Conclusões

# Possíveis Extensões
